Задачи реорганизации классов матриц и векторов.
	
	Логическая реорганизация:
		1. Создать шаблонные классы для векторов с параметром размера
			1.1. Класс вектора - это класс оболочка над std::array,
				 которая содержит тип элемента как typedef FloatTypeArg
				 и необходим, поскольку не следует наследоваться от класса std::array
		2. Создать шаблонные классы для матриц с параметром размера
	Физическая реорганизация: 
		1. Создать отдельные заголовочные файлы и поместить их в папку MathTypes

План реорганизации классов матриц и векторов:
1. НЕ следует создавать класс для определенного размера (Vec2, Vec3)
- лучше пользоваться параметризованным классом (к примеру, Vec<float, 2>)
2. Создать класс матрицы m * n
3. Создать операции для Vec размерности 2
4. Создать операции для Vec размерности 3
5. Создать операции для Vec размерности 4

Требования к векторам и матрицам:
		1. Прямой доступ к элементам матриц как к массиву
		2. Операции:
			2.1. Перемножение матриц и векторов	
			2.2. Преобразование в другие форматы:	
				2.2.1. Преобразование в сырой слепок памяти (GetPointer())			
			2.3. Операции, специфичные для вектора:
				2.3.1. Определение длины
					2.3.1.1. GetNormalized(), Normalize() +
					2.3.1.2. SqrLength, Length +
				2.3.2. Операции сложения и умножения
					2.3.2.1. Сложение и вычитание векторов +
					2.3.2.2. Умножение и деление на скаляр +
				2.3.3. Операции Dot и Cross
					2.3.3.1. Операция Dot +
					2.3.3.2. Операция Cross - необходима только для Vec3
			2.4. Получение строкового представления
		3. Конструкторы и операции Set:
			3.1. По умолчанию
			3.2. Создание вектора из набора компонент
			3.3. Создание вектора из std::array			
			3.4. Создание вектора из определенного фрагмента памяти (должен поддерживать все аргументы CopyCast)
			3.5. Создание вектора из вектора меньшего размера (с заполнением нулями отсутствующих компонентов)
			     и большего размера (с отсечением)
			3.6. Копирование с использованием const-итератора
			2.7. Создание вектора из DX11-типов:
				2.7.1. Типы:
					2.7.1.1 XMVECTOR
					2.7.1.2 XMFLOAT4, XMFLOAT3, XMFLOAT2
				2.7.2. Аргументы
					2.7.2.1. Количество компонентов для копирования
				2.7.3. Реализация:
					2.7.3.1. Лучше реализовать как глобальную функцию, которая использует конструктор для копирования 
							 из области памяти.
							`		


//-------------------------------------------------------------------------------------------------------------
1. Конструкторы некоторых типов зависят от других типов.
Пример: 
   Конструктор матрицы (Matrix) зависит от моего класса-вектора (Vector3).

2. Какого вида матрица? Column-major или row-major?
   column-major\row-major не имеет отношения к тому, какой вид векторов используется
   (row или column)
   Насчет HLSL5.0:
   "While IN.Position is the left parameter of mul, it is considered as a row vector. Otherwise it is considered as a column vector."
3. Нужно реализовать функцию перевода КООРДИНАТ точки (x,y,z) в определенной системе координат XYZ 
   в систему X`Y`Z`, которая является преобразованием системы XYZ с помощью некоторой данной матрицы M.
4. Когда может понадобиться вектор из четырех компонент?
5. XMMatrix may crash your program!!!
   XMMatrix всегда должен быть выровнен по границе 16 байт!!!
   (проблемы при аллокации в куче)
6. Должна быть возможность умножения ВЕКТОРА Vector3 на матрицу Matrix.

СОВЕТЫ ПО ОПТИМИЗАЦИИ:
1. Виды оптимизаций
   1.1. Оптимизация возвращения значенияб копирования значения
   1.2. Оптимизация кэширования (памяти)
   1.3. Оптимизация по предотвравщению вычисления оного значения несколько раз 
   (пример: XMMatrixInverse возвращает также и детерминант матрицы)
   1.4. оптимизации по выравниванию (пример: _declspec(align(16)) для XMMATRIX)
   1.5. inline, force inline для функций
   1.6. Флаги компилятора
   1.7. Исключение лишних вычислений (к примеру, IsZero для вектора вычисляет длину вектора зря и т.д.)
   1.8. Уменьшение размера копируемых данных 
   (к примеру, уменьшение размера матриц в шейдере, к примеру, до 3*3, 
    уменьшение размера данных, передаваемых на видеокарту)
   1.9. Оптимизации математики (математических выражений и т.д.)
   2.0. Оптимизация выделения памяти (например, если известно, что в строке около 50 символов, то зачем выделять память дважды?).

СОВЕТЫ ПО ОРГАНИЗАЦИИ:
1. Операции с Matrix.decompose(scale,rotQuat,trans), умножения вектора на матрицу
лучше оформить как внешние операции (заголовочный файл MathUtil_MatrixVectorQuat).